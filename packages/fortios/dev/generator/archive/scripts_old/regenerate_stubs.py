#!/usr/bin/env python3
"""
Regenerate Type Stub Files (.pyi) for FortiOS API

This utility regenerates __init__.pyi stub files for better IDE autocomplete
without regenerating the actual implementation code.

Purpose:
    - Fixes "Unresolved attribute" warnings in IDEs (PyCharm, VS Code, etc.)
    - Provides type hints for dynamic API structure (fgt.api.cmdb.firewall.policy)
    - Enables full PEP 561 compliance for type checkers

Usage:
    python regenerate_stubs.py

Generated Files:
    - packages/fortios/hfortix_fortios/api/v2/cmdb/__init__.pyi
    - packages/fortios/hfortix_fortios/api/v2/cmdb/firewall/__init__.pyi
    - ... and 246+ more __init__.pyi files

Note:
    - Individual endpoint .pyi files are generated by generate.py during code generation
    - This script only handles __init__.pyi files for category/subcategory wrappers
    - Core package (hfortix_core) uses inline type hints and doesn't need stubs
"""

import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent))

from generators.pyi_generator import PYIGenerator

# Paths
output_dir = Path("packages/fortios/hfortix_fortios/api/v2")
template_dir = Path(".dev/generator/templates")

# Initialize generator
pyi_gen = PYIGenerator(template_dir, output_dir)


def generate_stub_for_init(init_file: Path, class_name: str) -> None:
    """Generate stub for a single __init__.py file."""
    category_name = init_file.parent.name
    
    # Parse the __init__.py to find imports and self.xyz = assignments
    content = init_file.read_text()
    
    # Find all module imports (subdirectories)
    subdir_imports = []
    for line in content.split('\n'):
        line = line.strip()
        if line.startswith('from . import ') and not line.startswith('from .'):
            module = line.split('from . import ')[1].strip()
            subdir_imports.append(module)
    
    # Find all class imports (direct endpoints)
    class_imports = {}  # module_name -> ClassName
    for line in content.split('\n'):
        line = line.strip()
        if line.startswith('from .') and ' import ' in line and not line.startswith('from . import'):
            # e.g., from .policy import Policy
            parts = line.split(' import ')
            if len(parts) == 2:
                module = parts[0].replace('from .', '').strip()
                class_name_imported = parts[1].strip()
                class_imports[module] = class_name_imported
    
    # Find all self.xyz = assignments
    attributes = []
    for line in content.split('\n'):
        line = line.strip()
        if line.startswith('self.') and '=' in line:
            # Extract attribute name and class
            parts = line.split('=')
            attr_name = parts[0].replace('self.', '').strip()
            
            # Try to find the class name
            if '.' in parts[1] and '(' in parts[1]:
                # Pattern: self.firewall = firewall.Firewall(client)
                class_part = parts[1].split('(')[0].strip()
                if '.' in class_part:
                    module_name, cls_name = class_part.rsplit('.', 1)
                    attributes.append({
                        'attr_name': attr_name,
                        'module_name': module_name,
                        'class_name': cls_name
                    })
            elif '(' in parts[1]:
                # Pattern: self.policy = Policy(client)
                class_part = parts[1].split('(')[0].strip()
                # Try to find the module from class_imports
                for mod, cls in class_imports.items():
                    if cls == class_part:
                        attributes.append({
                            'attr_name': attr_name,
                            'module_name': mod,
                            'class_name': class_part
                        })
                        break
    
    if not attributes:
        return
    
    # Generate stub content
    stub_content = f'''"""Type stubs for {category_name.upper()} category."""

from __future__ import annotations

from typing import TYPE_CHECKING


if TYPE_CHECKING:
    from hfortix_core.http.interface import IHTTPClient
'''
    
    # Add imports for all modules
    all_modules = set()
    for attr in attributes:
        all_modules.add(attr['module_name'])
    
    for module in sorted(all_modules):
        stub_content += f"    from . import {module}\n"
    
    stub_content += "\n\n"
    
    # Generate class
    stub_content += f"class {class_name}:\n"
    stub_content += f'    """Type stub for {class_name}."""\n\n'
    
    # Add all attributes
    for attr in attributes:
        stub_content += f"    {attr['attr_name']}: {attr['module_name']}.{attr['class_name']}\n"
    
    stub_content += "\n    def __init__(self, client: IHTTPClient) -> None: ...\n"
    
    # Write stub file
    stub_file = init_file.parent / "__init__.pyi"
    stub_file.write_text(stub_content)
    return stub_file


# Generate stubs for all categories
categories = ["cmdb", "monitor", "log", "service"]

count = 0
for category in categories:
    category_dir = output_dir / category
    if not category_dir.exists():
        continue
    
    # Generate for top-level category
    init_file = category_dir / "__init__.py"
    if init_file.exists():
        class_name = category.upper() if category == "cmdb" else category.capitalize()
        stub_file = generate_stub_for_init(init_file, class_name)
        if stub_file:
            print(f"✅ {stub_file}")
            count += 1
    
    # Find all subcategories with __init__.py
    for subdir in category_dir.rglob("*"):
        if not subdir.is_dir():
            continue
        
        sub_init = subdir / "__init__.py"
        if not sub_init.exists():
            continue
        
        # Skip if it's already been processed or is a helper
        if subdir == category_dir or subdir.name.startswith("_"):
            continue
        
        # Infer class name from directory
        # e.g., firewall -> Firewall, switch_controller -> SwitchController
        dir_name = subdir.name
        class_name = ''.join(word.capitalize() for word in dir_name.replace('-', '_').split('_'))
        
        stub_file = generate_stub_for_init(sub_init, class_name)
        if stub_file:
            print(f"✅ {stub_file}")
            count += 1

print(f"\n{'='*60}")
print(f"✅ Generated {count} __init__.pyi stub files!")
print(f"{'='*60}")
print(f"\nType stub summary:")
print(f"  • __init__.pyi files: {count}")
print(f"  • Individual endpoint .pyi files: ~2,115 (generated by generate.py)")
print(f"  • Total: ~{count + 2115} type stub files")
print(f"\nNote: hfortix-core uses inline type hints (recommended for non-dynamic code)")
print(f"      and doesn't require separate .pyi stub files.")
print(f"\nAutocomplete should now work perfectly in:")
print(f"  • VS Code (Pylance)")
print(f"  • PyCharm")
print(f"  • Any PEP 561 compliant type checker")
print(f"\n{'='*60}\n")
