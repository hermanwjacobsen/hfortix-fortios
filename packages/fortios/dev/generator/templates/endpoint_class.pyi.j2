{# Template for generating .pyi stub files for endpoints #}
{# Simplified version - no dict mode, minimal overloads for type inference #}
"""{{ schema.description | default(schema.endpoint_name, true) }} - Type Stubs

Auto-generated stub file for type checking and IDE support.

Endpoint: {{ schema.path }}
Category: {{ schema.category }}
"""

from __future__ import annotations

from typing import (
    Any,
    ClassVar,
    Literal,
    TypedDict,
{% if schema.mkey and schema.category not in ['service', 'monitor'] %}
    overload,
{% endif %}
)

from hfortix_fortios.models import (
    FortiObject,
    FortiObjectList,
{% if is_content_endpoint %}
    ContentResponse,
{% endif %}
)


{% if schema.fields %}
# ================================================================
# TypedDict Payloads
# ================================================================

{# First pass: Generate TypedDicts for nested complex/table fields within table items #}
{% for field_name, field in schema.fields.items() if field.category == 'table' and field.children %}
{% set field_snake = field_name|kebab_to_snake %}
{% for child_name, child in field.children.items() if (child.category == 'table' or child.category == 'complex') and child.children %}
{% set child_snake = child_name|kebab_to_snake %}
{% if child.category == 'table' %}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Item(TypedDict, total=False):
    """Nested item for {{ field_name }}.{{ child_name }} field."""
{% for grandchild_name, grandchild in child.children.items() %}
{% set grandchild_snake = grandchild_name|kebab_to_snake %}
{% if grandchild.options %}
    {{ grandchild_snake }}: Literal[{{ grandchild.options|map('tojson')|join(', ') }}]
{% elif grandchild.type in ['integer', 'int'] %}
    {{ grandchild_snake }}: int{% if grandchild.is_list %} | list[int]{% endif %}

{% elif grandchild.type == 'boolean' %}
    {{ grandchild_snake }}: bool
{% else %}
    {{ grandchild_snake }}: str{% if grandchild.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% else %}
{# Complex fields nested in table items #}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Dict(TypedDict, total=False):
    """Nested object type for {{ field_name }}.{{ child_name }} field."""
{% for grandchild_name, grandchild in child.children.items() %}
{% set grandchild_snake = grandchild_name|kebab_to_snake %}
{% if grandchild.options %}
    {{ grandchild_snake }}: Literal[{{ grandchild.options|map('tojson')|join(', ') }}]
{% elif grandchild.type in ['integer', 'int'] %}
    {{ grandchild_snake }}: int{% if grandchild.is_list %} | list[int]{% endif %}

{% elif grandchild.type == 'boolean' %}
    {{ grandchild_snake }}: bool
{% else %}
    {{ grandchild_snake }}: str{% if grandchild.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% endif %}
{% endfor %}
{% endfor %}
{# Second pass: Generate TypedDicts for nested complex/table fields within complex objects #}
{% for field_name, field in schema.fields.items() if field.category == 'complex' and field.children %}
{% set field_snake = field_name|kebab_to_snake %}
{% for child_name, child in field.children.items() if (child.category == 'table' or child.category == 'complex') and child.children %}
{% set child_snake = child_name|kebab_to_snake %}
{% if child.category == 'table' %}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Item(TypedDict, total=False):
    """Nested item for {{ field_name }}.{{ child_name }} field."""
{% for grandchild_name, grandchild in child.children.items() %}
{% set grandchild_snake = grandchild_name|kebab_to_snake %}
{% if grandchild.options %}
    {{ grandchild_snake }}: Literal[{{ grandchild.options|map('tojson')|join(', ') }}]
{% elif grandchild.type in ['integer', 'int'] %}
    {{ grandchild_snake }}: int{% if grandchild.is_list %} | list[int]{% endif %}

{% elif grandchild.type == 'boolean' %}
    {{ grandchild_snake }}: bool
{% else %}
    {{ grandchild_snake }}: str{% if grandchild.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% else %}
{# Complex fields nested in complex objects #}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Dict(TypedDict, total=False):
    """Nested object type for {{ field_name }}.{{ child_name }} field."""
{% for grandchild_name, grandchild in child.children.items() %}
{% set grandchild_snake = grandchild_name|kebab_to_snake %}
{% if grandchild.options %}
    {{ grandchild_snake }}: Literal[{{ grandchild.options|map('tojson')|join(', ') }}]
{% elif grandchild.type in ['integer', 'int'] %}
    {{ grandchild_snake }}: int{% if grandchild.is_list %} | list[int]{% endif %}

{% elif grandchild.type == 'boolean' %}
    {{ grandchild_snake }}: bool
{% else %}
    {{ grandchild_snake }}: str{% if grandchild.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% endif %}
{% endfor %}
{% endfor %}
{# Third pass: Generate TypedDicts for top-level table/complex fields #}
{% for field_name, field in schema.fields.items() if (field.category == 'table' or field.category == 'complex') and field.children %}
{% set field_snake = field_name|kebab_to_snake %}
{% if field.category == 'table' %}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item(TypedDict, total=False):
    """Nested item for {{ field_name }} field."""
{% else %}
{# Complex fields are single nested objects, not lists #}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Dict(TypedDict, total=False):
    """Nested object type for {{ field_name }} field."""
{% endif %}
{% for child_name, child in field.children.items() %}
{% set child_snake = child_name|kebab_to_snake %}
{% if child.category == 'complex' and child.children %}
{# Nested complex object within table item #}
    {{ child_snake }}: {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Dict
{% elif child.category == 'table' and child.children %}
{# Nested table within table item #}
    {{ child_snake }}: str | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Item]
{% elif child.options %}
    {{ child_snake }}: Literal[{{ child.options|map('tojson')|join(', ') }}]
{% elif child.type in ['integer', 'int'] %}
    {{ child_snake }}: int{% if child.is_list %} | list[int]{% endif %}

{% elif child.type == 'boolean' %}
    {{ child_snake }}: bool
{% else %}
    {{ child_snake }}: str{% if child.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% endfor %}
{# Keep TypedDict for Payload (input) since users construct dicts #}
class {{ schema.class_name }}Payload(TypedDict, total=False):
    """Payload type for {{ schema.class_name }} operations."""
{% for field_name, field in schema.fields.items() %}
{% set field_snake = field_name|kebab_to_snake %}
{% if field.category == 'complex' and field.children %}
{# Complex fields are single nested objects (not lists) #}
    {{ field_snake }}: {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Dict
{% elif field.category == 'table' and field.children %}
{# Table fields with children - use typed list for IDE validation #}
{% if field.options %}
    {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}] | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item]
{% elif field.type in ['integer', 'int'] %}
    {{ field_snake }}: int | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item]
{% else %}
    {{ field_snake }}: str | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item]
{% endif %}
{% elif field.options and field.is_list and field.category != 'table' %}
{# Multi-value option fields (space-separated strings like "monday tuesday wednesday") #}
{# Payload accepts str or list[str] for convenience - library normalizes to space-separated string #}
    {{ field_snake }}: str | list[str]
{% elif field.options %}
    {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}]
{% elif field.type in ['integer', 'int'] %}
    {{ field_snake }}: int{% if field.is_list %} | list[int]{% endif %}

{% elif field.type == 'boolean' %}
    {{ field_snake }}: bool
{% elif field.type == 'array' %}
{# Array fields should be list[str] to avoid type variance issues #}
    {{ field_snake }}: list[str]
{% else %}
    {{ field_snake }}: str{% if field.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}

{% endif %}

{% if schema.response_fields %}
# ================================================================
# Response Types for Monitor/Log/Service Endpoints
# ================================================================

class {{ schema.class_name }}Response(TypedDict, total=False):
    """Response type for {{ schema.class_name }} - use with .dict property for typed dict access."""
{% for field_name, field_info in schema.response_fields.items() %}
{% set field_snake = field_info.python_name | default(field_name|kebab_to_snake, true) %}
{% if field_info.pydantic_type %}
    {{ field_snake }}: {{ field_info.pydantic_type }}
{% elif field_info.type == 'integer' or field_info.type == 'int' %}
    {{ field_snake }}: int
{% elif field_info.type == 'boolean' or field_info.type == 'bool' %}
    {{ field_snake }}: bool
{% elif field_info.type == 'array' %}
    {{ field_snake }}: list[str]
{% else %}
    {{ field_snake }}: str
{% endif %}
{% endfor %}


class {{ schema.class_name }}Object(FortiObject[{{ schema.class_name }}Response]):
    """Typed FortiObject for {{ schema.class_name }} with field access."""
{% for field_name, field_info in schema.response_fields.items() %}
{% set field_snake = field_info.python_name | default(field_name|kebab_to_snake, true) %}
{% if field_info.pydantic_type %}
    {{ field_snake }}: {{ field_info.pydantic_type }}
{% elif field_info.type == 'integer' or field_info.type == 'int' %}
    {{ field_snake }}: int
{% elif field_info.type == 'boolean' or field_info.type == 'bool' %}
    {{ field_snake }}: bool
{% elif field_info.type == 'array' %}
    {{ field_snake }}: list[str]
{% else %}
    {{ field_snake }}: str
{% endif %}
{% endfor %}

{% elif schema.fields %}
# ================================================================
# Response Types (TypedDict for dict-style access)
# ================================================================

class {{ schema.class_name }}Response(TypedDict, total=False):
    """Response type for {{ schema.class_name }} - use with .dict property for typed dict access."""
{% for field_name, field in schema.fields.items() %}
{% set field_snake = field_name|kebab_to_snake %}
{% if field.category == 'complex' and field.children %}
{# Complex fields are single nested objects #}
    {{ field_snake }}: {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Dict
{% elif field.category == 'table' and field.children %}
    {{ field_snake }}: list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item]
{% elif field.options and field.is_list and field.category != 'table' %}
{# Multi-value option fields return space-separated strings (e.g., "monday tuesday wednesday") #}
    {{ field_snake }}: str
{% elif field.options %}
    {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}]
{% elif field.type in ['integer', 'int'] %}
    {{ field_snake }}: int{% if field.is_list %} | list[int]{% endif %}

{% elif field.type == 'boolean' %}
    {{ field_snake }}: bool
{% elif field.type == 'array' %}
{# Simple array fields - responses typically return list[str] #}
    {{ field_snake }}: list[str]
{% else %}
    {{ field_snake }}: str{% if field.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}

{% endif %}

{% if schema.fields and not schema.response_fields %}
# ================================================================
# Response Types (Class for attribute access)
# ================================================================

{# Reserved field names that conflict with FortiObject base class properties #}
{# Note: 'status' is NOT reserved - base class has 'http_status' but child fields like 'status' (enable/disable) are valid #}
{% set reserved_fields = ['vdom', 'serial', 'version', 'revision', 'http_status', 'mkey', 'build', 'list'] %}

{# First: Create object classes for nested table items within table items (must come before parent table items) #}
{% for field_name, field in schema.fields.items() if field.category == 'table' and field.children %}
{% set field_snake = field_name|kebab_to_snake %}
{% for child_name, child in field.children.items() if child.category == 'table' and child.children %}
{% set child_snake = child_name|kebab_to_snake %}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}ItemObject(FortiObject[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Item]):
    """Typed object for {{ field_name }}.{{ child_name }} table items with attribute access."""
{% for grandchild_name, grandchild in child.children.items() %}
{% set grandchild_snake = grandchild_name|kebab_to_snake %}
{% if grandchild.options %}
    {{ grandchild_snake }}: Literal[{{ grandchild.options|map('tojson')|join(', ') }}]
{% elif grandchild.type in ['integer', 'int'] %}
    {{ grandchild_snake }}: int{% if grandchild.is_list %} | list[int]{% endif %}

{% elif grandchild.type == 'boolean' %}
    {{ grandchild_snake }}: bool
{% else %}
    {{ grandchild_snake }}: str{% if grandchild.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% endfor %}
{% endfor %}
{# Second: Create classes for table item fields to enable typed attribute access #}
{% for field_name, field in schema.fields.items() if field.category == 'table' and field.children %}
{% set field_snake = field_name|kebab_to_snake %}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}ItemObject(FortiObject[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item]):
    """Typed object for {{ field_name }} table items with attribute access."""
{% for child_name, child in field.children.items() %}
{% set child_snake = child_name|kebab_to_snake %}
{% if child.category == 'complex' and child.children %}
{# Nested complex object within table item - NOT a list #}
    {{ child_snake }}: {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Object
{% elif child.category == 'table' and child.children %}
{# Nested table within table item #}
    {{ child_snake }}: FortiObjectList[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}ItemObject]
{% elif child.options %}
    {{ child_snake }}: Literal[{{ child.options|map('tojson')|join(', ') }}]
{% elif child.type in ['integer', 'int'] %}
    {{ child_snake }}: int{% if child.is_list %} | list[int]{% endif %}

{% elif child.type == 'boolean' %}
    {{ child_snake }}: bool
{% else %}
    {{ child_snake }}: str{% if child.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% endfor %}
{# Create object classes for nested complex fields within table items #}
{% for field_name, field in schema.fields.items() if field.category == 'table' and field.children %}
{% set field_snake = field_name|kebab_to_snake %}
{% for child_name, child in field.children.items() if child.category == 'complex' and child.children %}
{% set child_snake = child_name|kebab_to_snake %}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Object(FortiObject):
    """Nested object for {{ field_name }}.{{ child_name }} field with attribute access."""
{% for grandchild_name, grandchild in child.children.items() %}
{% set grandchild_snake = grandchild_name|kebab_to_snake %}
{% if grandchild.options %}
    {{ grandchild_snake }}: Literal[{{ grandchild.options|map('tojson')|join(', ') }}]
{% elif grandchild.type in ['integer', 'int'] %}
    {{ grandchild_snake }}: int{% if grandchild.is_list %} | list[int]{% endif %}

{% elif grandchild.type == 'boolean' %}
    {{ grandchild_snake }}: bool
{% else %}
    {{ grandchild_snake }}: str{% if grandchild.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% endfor %}
{% endfor %}
{# Create object classes for nested table items within complex objects #}
{% for field_name, field in schema.fields.items() if field.category == 'complex' and field.children %}
{% set field_snake = field_name|kebab_to_snake %}
{% for child_name, child in field.children.items() if child.category == 'table' and child.children %}
{% set child_snake = child_name|kebab_to_snake %}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}ItemObject(FortiObject[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}{{ child_snake|title|replace('_', '') }}Item]):
    """Typed object for {{ field_name }}.{{ child_name }} table items with attribute access."""
{% for grandchild_name, grandchild in child.children.items() %}
{% set grandchild_snake = grandchild_name|kebab_to_snake %}
{% if grandchild.options %}
    {{ grandchild_snake }}: Literal[{{ grandchild.options|map('tojson')|join(', ') }}]
{% elif grandchild.type in ['integer', 'int'] %}
    {{ grandchild_snake }}: int{% if grandchild.is_list %} | list[int]{% endif %}

{% elif grandchild.type == 'boolean' %}
    {{ grandchild_snake }}: bool
{% else %}
    {{ grandchild_snake }}: str{% if grandchild.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% endfor %}
{% endfor %}
{# Create classes for nested object fields to enable attribute access #}
{% for field_name, field in schema.fields.items() if field.category == 'complex' and field.children %}
{% set field_snake = field_name|kebab_to_snake %}
class {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Object(FortiObject):
    """Nested object for {{ field_name }} field with attribute access."""
{% for child_name, child in field.children.items() %}
{% set child_snake = child_name|kebab_to_snake %}
{% if child.category == 'table' and child.children %}
{# Nested table within complex object #}
    {{ child_snake }}: str | list[str]
{% elif child.options %}
    {{ child_snake }}: Literal[{{ child.options|map('tojson')|join(', ') }}]
{% elif child.type in ['integer', 'int'] %}
    {{ child_snake }}: int{% if child.is_list %} | list[int]{% endif %}

{% elif child.type == 'boolean' %}
    {{ child_snake }}: bool
{% else %}
    {{ child_snake }}: str{% if child.is_list %} | list[str]{% endif %}

{% endif %}
{% endfor %}


{% endfor %}
class {{ schema.class_name }}Object(FortiObject):
    """Typed FortiObject for {{ schema.class_name }} with field access."""
{% for field_name, field in schema.fields.items() %}
{% set field_snake = field_name|kebab_to_snake %}
{# Skip reserved field names to avoid type conflicts with FortiObject base class #}
{% if field_snake not in reserved_fields %}
{% if field.category == 'complex' and field.children %}
{# Complex fields are single nested objects - use Object class for attribute access #}
    {{ field_snake }}: {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Object
{% elif field.category == 'table' and field.children %}
{# Table fields with children - always returns FortiObjectList (even when empty) for consistent .dict access #}
    {{ field_snake }}: FortiObjectList[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}ItemObject]
{% elif field.options and field.is_list and field.category != 'table' %}
{# Multi-value option fields return space-separated strings (e.g., "monday tuesday wednesday") #}
    {{ field_snake }}: str
{% elif field.options %}
    {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}]
{% elif field.type in ['integer', 'int'] %}
    {{ field_snake }}: int{% if field.is_list %} | list[int]{% endif %}

{% elif field.type == 'boolean' %}
    {{ field_snake }}: bool
{% elif field.type == 'array' %}
{# Simple array fields - responses typically return list[str] #}
    {{ field_snake }}: list[str]
{% else %}
    {{ field_snake }}: str{% if field.is_list %} | list[str]{% endif %}

{% endif %}
{% endif %}
{% endfor %}

{% endif %}

# ================================================================
# Main Endpoint Class
# ================================================================

class {{ schema.class_name }}:
    """{{ schema.description | default(schema.endpoint_name, true) }}
    
    Endpoint: {{ schema.path }}
    Category: {{ schema.category }}
{% if schema.mkey %}
    MKey: {{ schema.mkey }}
{% endif %}
    """
    
    # Class attributes for introspection
    endpoint: ClassVar[str] = ...
    path: ClassVar[str] = ...
    category: ClassVar[str] = ...
{% if schema.mkey %}
    mkey: ClassVar[str] = ...
{% endif %}
{% if schema.capabilities %}
    capabilities: ClassVar[dict[str, Any]] = ...
{% endif %}
    
    def __init__(self, client: Any) -> None:
        """Initialize endpoint with HTTP client."""
        ...
    
    # ================================================================
    # GET Methods
    # ================================================================
    
{% if is_content_endpoint %}
    # Content endpoint - returns ContentResponse
    def get(
        self,
        *,
{% if query_params and query_params.GET %}
{% for param_name, param_info in query_params.GET.items() %}
{% set param_snake = param_name|kebab_to_snake %}
{% if param_info.allowed_values %}
{% set param_type = 'Literal[' + (param_info.allowed_values|map('tojson')|join(', ')) + ']' %}
{% elif param_info.enum %}
{% set param_type = 'Literal[' + (param_info.enum|map('tojson')|join(', ')) + ']' %}
{% elif param_info.type == 'boolean' %}
{% set param_type = 'bool' %}
{% elif param_info.type in ['integer', 'int'] %}
{% set param_type = 'int' %}
{% elif param_info.type == 'array' %}
{% set param_type = 'list[str]' %}
{% elif param_info.type == 'object' %}
{% set param_type = 'dict[str, Any]' %}
{% else %}
{% set param_type = 'str' %}
{% endif %}
{% if param_info.required %}
        {{ param_snake }}: {{ param_type }},
{% else %}
        {{ param_snake }}: {{ param_type }} | None = ...,
{% endif %}
{% endfor %}
{% endif %}
        filter: str | list[str] | None = ...,
        count: int | None = ...,
        start: int | None = ...,
        payload_dict: dict[str, Any] | None = ...,
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
        error_mode: Literal["raise", "return", "print"] | None = ...,
        error_format: Literal["detailed", "simple", "code_only"] | None = ...,
    ) -> ContentResponse: ...
{% elif schema.category in ['service', 'monitor'] %}
    # Service/Monitor endpoint
    def get(
        self,
        *,
{% if query_params and query_params.GET %}
{% for param_name, param_info in query_params.GET.items() %}
{% set param_snake = param_name|kebab_to_snake %}
{% if param_info.allowed_values %}
{% set param_type = 'Literal[' + (param_info.allowed_values|map('tojson')|join(', ')) + ']' %}
{% elif param_info.enum %}
{% set param_type = 'Literal[' + (param_info.enum|map('tojson')|join(', ')) + ']' %}
{% elif param_info.type == 'boolean' %}
{% set param_type = 'bool' %}
{% elif param_info.type in ['integer', 'int'] %}
{% set param_type = 'int' %}
{% elif param_info.type == 'array' %}
{% set param_type = 'list[str]' %}
{% elif param_info.type == 'object' %}
{% set param_type = 'dict[str, Any]' %}
{% else %}
{% set param_type = 'str' %}
{% endif %}
{% if param_info.required %}
        {{ param_snake }}: {{ param_type }},
{% else %}
        {{ param_snake }}: {{ param_type }} | None = ...,
{% endif %}
{% endfor %}
{% endif %}
{% if not query_params or not query_params.GET or 'filter' not in query_params.GET %}
        filter: str | list[str] | None = ...,
{% endif %}
{% if not query_params or not query_params.GET or 'count' not in query_params.GET %}
        count: int | None = ...,
{% endif %}
{% if not query_params or not query_params.GET or 'start' not in query_params.GET %}
        start: int | None = ...,
{% endif %}
        payload_dict: dict[str, Any] | None = ...,
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
        error_mode: Literal["raise", "return", "print"] | None = ...,
        error_format: Literal["detailed", "simple", "code_only"] | None = ...,
{% if schema.response_fields %}
    ) -> FortiObjectList[{{ schema.class_name }}Object]: ...
{% elif schema.fields %}
    ) -> {{ schema.class_name }}Object: ...
{% else %}
    ) -> FortiObject[Any]: ...
{% endif %}
{% elif schema.mkey %}
    # CMDB with mkey - overloads for single vs list returns
    @overload
    def get(
        self,
        {{ schema.mkey|kebab_to_snake }}: {{ schema.mkey_type|to_python_type }},
        *,
        filter: str | list[str] | None = ...,
        count: int | None = ...,
        start: int | None = ...,
        payload_dict: dict[str, Any] | None = ...,
        range: list[int] | None = ...,
        sort: str | None = ...,
        format: str | None = ...,
        action: str | None = ...,
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
        error_mode: Literal["raise", "return", "print"] | None = ...,
        error_format: Literal["detailed", "simple", "code_only"] | None = ...,
{% if schema.fields %}
    ) -> {{ schema.class_name }}Object: ...
{% else %}
    ) -> FortiObject[Any]: ...
{% endif %}
    
    @overload
    def get(
        self,
        *,
        filter: str | list[str] | None = ...,
        count: int | None = ...,
        start: int | None = ...,
        payload_dict: dict[str, Any] | None = ...,
        range: list[int] | None = ...,
        sort: str | None = ...,
        format: str | None = ...,
        action: str | None = ...,
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
        error_mode: Literal["raise", "return", "print"] | None = ...,
        error_format: Literal["detailed", "simple", "code_only"] | None = ...,
{% if schema.fields %}
    ) -> FortiObjectList[{{ schema.class_name }}Object]: ...
{% else %}
    ) -> FortiObjectList[FortiObject[Any]]: ...
{% endif %}
{% else %}
    # Singleton endpoint (no mkey)
    def get(
        self,
        *,
        filter: str | list[str] | None = ...,
        count: int | None = ...,
        start: int | None = ...,
        payload_dict: dict[str, Any] | None = ...,
        range: list[int] | None = ...,
        sort: str | None = ...,
        format: str | None = ...,
        action: str | None = ...,
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
        error_mode: Literal["raise", "return", "print"] | None = ...,
        error_format: Literal["detailed", "simple", "code_only"] | None = ...,
{% if schema.fields %}
    ) -> {{ schema.class_name }}Object: ...
{% else %}
    ) -> FortiObject[Any]: ...
{% endif %}
{% endif %}
    
{% if schema.capabilities and schema.capabilities.features and schema.capabilities.features.schema_introspection %}
    def get_schema(
        self,
{% if not schema.is_global_only %}
        vdom: str | None = ...,
{% endif %}
        format: str = ...,
    ) -> FortiObject: ...
{% endif %}

{% if not schema.readonly and schema.capabilities and schema.capabilities.crud and schema.capabilities.crud.create %}
    # ================================================================
    # POST Method
    # ================================================================
    
    def post(
        self,
{% if schema.fields %}
        payload_dict: {{ schema.class_name }}Payload | None = ...,
{% else %}
        payload_dict: dict[str, Any] | None = ...,
{% endif %}
{% for field_name, field in schema.fields.items() %}
{% set field_snake = field_name|kebab_to_snake %}
{% if field_snake not in ['vdom', 'kwargs', 'class', 'def', 'import', 'from', 'global', 'return', 'if', 'elif', 'else', 'for', 'while', 'with', 'try', 'except', 'finally', 'raise', 'assert', 'pass', 'break', 'continue', 'lambda', 'yield'] %}
{% if field.category == 'complex' and field.children %}
{# Complex fields are single nested objects #}
        {{ field_snake }}: {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Dict | None = ...,
{% elif field.category == 'table' and field.children %}
{# Table fields - allow str, list[str], list[dict], or list[TypedItem] for convenience #}
{% if field.options %}
        {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}] | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item] | None = ...,
{% elif field.type in ['integer', 'int'] %}
        {{ field_snake }}: int | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item] | None = ...,
{% else %}
        {{ field_snake }}: str | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item] | None = ...,
{% endif %}
{% elif field.options and field.is_list and field.category != 'table' %}
{# Multi-value option fields (space-separated strings) - accept str or list #}
        {{ field_snake }}: str | list[str] | None = ...,
{% elif field.options %}
        {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}] | None = ...,
{% elif field.type in ['integer', 'int'] %}
        {{ field_snake }}: int{% if field.is_list %} | list[int]{% endif %} | None = ...,
{% elif field.type == 'boolean' %}
        {{ field_snake }}: bool | None = ...,
{% elif field.type == 'array' %}
{# Simple array fields - accept flexible input types for convenience #}
        {{ field_snake }}: list[str] | None = ...,
{% else %}
        {{ field_snake }}: str{% if field.is_list %} | list[str]{% endif %} | None = ...,
{% endif %}
{% endif %}
{% endfor %}
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
        error_mode: Literal["raise", "return", "print"] | None = ...,
        error_format: Literal["detailed", "simple", "code_only"] | None = ...,
{% if schema.fields %}
    ) -> {{ schema.class_name }}Object: ...
{% else %}
    ) -> FortiObject[Any]: ...
{% endif %}
{% endif %}

{% if not schema.readonly and schema.capabilities and schema.capabilities.crud and schema.capabilities.crud.update %}
    # ================================================================
    # PUT Method
    # ================================================================
    
    def put(
        self,
{% if schema.fields %}
        payload_dict: {{ schema.class_name }}Payload | None = ...,
{% else %}
        payload_dict: dict[str, Any] | None = ...,
{% endif %}
{% for field_name, field in schema.fields.items() %}
{% set field_snake = field_name|kebab_to_snake %}
{% if field_snake not in ['vdom', 'kwargs', 'class', 'def', 'import', 'from', 'global', 'return', 'if', 'elif', 'else', 'for', 'while', 'with', 'try', 'except', 'finally', 'raise', 'assert', 'pass', 'break', 'continue', 'lambda', 'yield'] %}
{% if field.category == 'complex' and field.children %}
{# Complex fields are single nested objects #}
        {{ field_snake }}: {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Dict | None = ...,
{% elif field.category == 'table' and field.children %}
{# Table fields - allow str, list[str], list[dict], or list[TypedItem] for convenience #}
{% if field.options %}
        {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}] | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item] | None = ...,
{% elif field.type in ['integer', 'int'] %}
        {{ field_snake }}: int | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item] | None = ...,
{% else %}
        {{ field_snake }}: str | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item] | None = ...,
{% endif %}
{% elif field.options and field.is_list and field.category != 'table' %}
{# Multi-value option fields (space-separated strings) - accept str or list #}
        {{ field_snake }}: str | list[str] | None = ...,
{% elif field.options %}
        {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}] | None = ...,
{% elif field.type in ['integer', 'int'] %}
        {{ field_snake }}: int{% if field.is_list %} | list[int]{% endif %} | None = ...,
{% elif field.type == 'boolean' %}
        {{ field_snake }}: bool | None = ...,
{% elif field.type == 'array' %}
{# Simple array fields - accept flexible input types for convenience #}
        {{ field_snake }}: list[str] | None = ...,
{% else %}
        {{ field_snake }}: str{% if field.is_list %} | list[str]{% endif %} | None = ...,
{% endif %}
{% endif %}
{% endfor %}
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
        error_mode: Literal["raise", "return", "print"] | None = ...,
        error_format: Literal["detailed", "simple", "code_only"] | None = ...,
{% if schema.fields %}
    ) -> {{ schema.class_name }}Object: ...
{% else %}
    ) -> FortiObject[Any]: ...
{% endif %}
{% endif %}

{% if not schema.readonly and schema.capabilities and schema.capabilities.crud and schema.capabilities.crud.delete %}
    # ================================================================
    # DELETE Method
    # ================================================================
    
    def delete(
        self,
{% if schema.mkey %}
        {{ schema.mkey|kebab_to_snake }}: {{ schema.mkey_type|to_python_type }} | None = ...,
{% else %}
        name: str | None = ...,
{% endif %}
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
        error_mode: Literal["raise", "return", "print"] | None = ...,
        error_format: Literal["detailed", "simple", "code_only"] | None = ...,
    ) -> FortiObject[Any]: ...
{% endif %}

    # ================================================================
    # Utility Methods
    # ================================================================
    
    def exists(
        self,
{% if schema.mkey %}
        {{ schema.mkey|kebab_to_snake }}: {{ schema.mkey_type|to_python_type }},
{% else %}
        name: str,
{% endif %}
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
    ) -> bool: ...
    
    def set(
        self,
{% if schema.fields %}
        payload_dict: {{ schema.class_name }}Payload | None = ...,
{% else %}
        payload_dict: dict[str, Any] | None = ...,
{% endif %}
{% for field_name, field in schema.fields.items() %}
{% set field_snake = field_name|kebab_to_snake %}
{% if field_snake not in ['vdom', 'kwargs', 'class', 'def', 'import', 'from', 'global', 'return', 'if', 'elif', 'else', 'for', 'while', 'with', 'try', 'except', 'finally', 'raise', 'assert', 'pass', 'break', 'continue', 'lambda', 'yield'] %}
{% if field.category == 'complex' and field.children %}
{# Complex fields are single nested objects #}
        {{ field_snake }}: {{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Dict | None = ...,
{% elif field.category == 'table' and field.children %}
{# Table fields - allow str, list[str], list[dict], or list[TypedItem] for convenience #}
{% if field.options %}
        {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}] | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item] | None = ...,
{% elif field.type in ['integer', 'int'] %}
        {{ field_snake }}: int | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item] | None = ...,
{% else %}
        {{ field_snake }}: str | list[str] | list[{{ schema.class_name }}{{ field_snake|title|replace('_', '') }}Item] | None = ...,
{% endif %}
{% elif field.options %}
        {{ field_snake }}: Literal[{{ field.options|map('tojson')|join(', ') }}]{% if field.is_list %} | list[str]{% endif %} | None = ...,
{% elif field.type in ['integer', 'int'] %}
        {{ field_snake }}: int{% if field.is_list %} | list[int]{% endif %} | None = ...,
{% elif field.type == 'boolean' %}
        {{ field_snake }}: bool | None = ...,
{% elif field.type == 'array' %}
{# Simple array fields - accept flexible input types for convenience #}
        {{ field_snake }}: list[str] | None = ...,
{% else %}
        {{ field_snake }}: str{% if field.is_list %} | list[str]{% endif %} | None = ...,
{% endif %}
{% endif %}
{% endfor %}
{% if not schema.is_global_only %}
        vdom: str | bool | None = ...,
{% endif %}
        error_mode: Literal["raise", "return", "print"] | None = ...,
        error_format: Literal["detailed", "simple", "code_only"] | None = ...,
    ) -> FortiObject[Any]: ...
    
    # Helper methods
    @staticmethod
    def help(field_name: str | None = ...) -> str: ...
    
    @staticmethod
    def fields(detailed: bool = ...) -> list[str] | list[dict[str, Any]]: ...
    
    @staticmethod
    def field_info(field_name: str) -> FortiObject[Any]: ...
    
    @staticmethod
    def validate_field(name: str, value: Any) -> bool: ...
    
    @staticmethod
    def required_fields() -> list[str]: ...
    
    @staticmethod
    def defaults() -> FortiObject[Any]: ...
    
    @staticmethod
    def schema() -> FortiObject[Any]: ...


__all__ = [
    "{{ schema.class_name }}",
{% if schema.response_fields %}
    "{{ schema.class_name }}Response",
    "{{ schema.class_name }}Object",
{% elif schema.fields %}
    "{{ schema.class_name }}Payload",
    "{{ schema.class_name }}Response",
    "{{ schema.class_name }}Object",
{% endif %}
]
